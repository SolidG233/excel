<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let SCREEN_W = canvas.parentElement.clientWidth;
let SCREEN_H = canvas.parentElement.clientHeight;

// --- 游戏常量 ---
const GRAVITY = 0.8;
const BLOCK_SIZE = { w: 80, h: 30 };
const GOAL_DISTANCE = 5000; 
const MAX_JUMP_FORCE = 10; 
let gameConfig = { chargeDivisor: 30 }; 

// 网络变量
let peer = null;
// connections 改为对象映射，key为玩家ID(1或2)，value为连接对象
let clientSlots = { 1: null, 2: null }; 
let myConn = null;    
let myId = null;
let role = 'SPECTATOR'; 
let myPlayerIndex = -1; 

// 游戏状态
let gameState = {
    status: 'MENU', 
    blocks: [],     
    winner: null,
    players: [
        { id: 0, char: '@', color: '#000', x: 0, y: 0, vx: 0, vy: 0, charging: 0, onGround: true, finished: false, lastSafeX: 0, active: true },
        { id: 1, char: '&', color: '#000', x: 0, y: 0, vx: 0, vy: 0, charging: 0, onGround: true, finished: false, lastSafeX: 0, active: false },
        { id: 2, char: '%', color: '#000', x: 0, y: 0, vx: 0, vy: 0, charging: 0, onGround: true, finished: false, lastSafeX: 0, active: false }
    ]
};

let localCameraX = 0;
let isPressing = false;
let pressStartTime = 0;

function log(msg, type='normal') {
    const bar = document.getElementById('status-bar');
    bar.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
    if(type === 'error') bar.className = 'log-error';
    else if(type === 'success') bar.className = 'log-success';
    else bar.className = '';
}

// --- 绘图逻辑 ---
function drawGrid() {
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    const offsetX = localCameraX % 50;
    for (let x = -offsetX; x < SCREEN_W; x += 50) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, SCREEN_H); ctx.stroke();
    }
    for (let y = 0; y < SCREEN_H; y += 25) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(SCREEN_W, y); ctx.stroke();
    }
    ctx.fillStyle = '#f3f3f3';
    ctx.fillRect(0, 0, 30, SCREEN_H);
    ctx.fillStyle = '#999';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    for (let y = 20; y < SCREEN_H; y += 25) {
        ctx.fillText(Math.floor(y/25), 15, y);
    }
}

// --- 网络逻辑 ---
function initPeer(mode) {
    log("正在初始化网络模块...", "normal");
    try {
        peer = new Peer({ debug: 1 }); 
    } catch (e) {
        log("PeerJS加载失败", "error");
        return;
    }

    peer.on('open', (id) => {
        myId = id;
        log("网络已就绪", "success");
        if (mode === 'HOST') {
            document.getElementById('my-id-display').value = id;
            document.getElementById('host-area').style.display = 'block';
            document.getElementById('join-area').style.display = 'none';
        } else if (mode === 'JOIN') {
             const hostId = document.getElementById('host-id-input').value.trim();
             if(hostId) connectToHost(hostId);
        }
    });

    peer.on('connection', (c) => {
        if (role === 'HOST') {
            // 寻找空闲座位 (1 或 2)
            let assignedSlot = -1;
            if (!clientSlots[1]) assignedSlot = 1;
            else if (!clientSlots[2]) assignedSlot = 2;

            if (assignedSlot === -1) {
                c.close(); // 满员
                return;
            }
            
            // 绑定座位
            clientSlots[assignedSlot] = c;
            setupHostConnection(c, assignedSlot);
            
            // 激活玩家
            gameState.players[assignedSlot].active = true;
            
            log(`玩家 P${assignedSlot+1} 已连接！`, "success");
            updateHostStatus();
        }
    });

    peer.on('error', (err) => {
        console.error(err);
        let errorMsg = "网络错误";
        if (err.type === 'peer-unavailable') errorMsg = "找不到该ID";
        log(`Error: ${errorMsg}`, "error");
    });
}

function updateHostStatus() {
    let count = 0;
    if(clientSlots[1]) count++;
    if(clientSlots[2]) count++;
    document.getElementById('host-status').innerText = `已连接: ${count}/2`;
    document.getElementById('start-btn').disabled = false;
    document.getElementById('start-btn').innerText = `开始计算 (${count+1}人)`;
}

function startSinglePlayer() {
    role = 'SINGLE';
    myPlayerIndex = 0;
    document.getElementById('menu-panel').style.display = 'none';
    log("模式: 单机离线", "normal");
    startGame();
}

function createGame() {
    role = 'HOST';
    myPlayerIndex = 0;
    document.getElementById('join-area').style.display = 'none';
    initPeer('HOST');
}

function toggleJoin() {
    document.getElementById('host-area').style.display = 'none';
    document.getElementById('join-area').style.display = 'block';
}

function joinGame() {
    role = 'CLIENT';
    const hostId = document.getElementById('host-id-input').value.trim();
    if (!hostId) { alert("请输入房主ID"); return; }
    if (!peer) initPeer('JOIN');
    else connectToHost(hostId);
}

function connectToHost(hostId) {
    log(`正在连接...`, "normal");
    myConn = peer.connect(hostId);
    
    myConn.on('open', () => { 
        log("已连接，等待分配ID...", "success"); 
        document.getElementById('menu-panel').style.display = 'none';
    });
    
    myConn.on('data', (data) => {
        if (data.type === 'ASSIGN_ID') {
            myPlayerIndex = data.id;
            log(`身份确认: Player ${myPlayerIndex + 1}`, "success");
        }
        if (data.type === 'SYNC') {
            gameState = data.state;
            if(gameState.status === 'PLAYING' && document.getElementById('menu-panel').style.display !== 'none') {
                 document.getElementById('menu-panel').style.display = 'none';
            }
            updateUI();
        }
        if (data.type === 'RESTART') {
             document.getElementById('game-over-panel').style.display = 'none';
        }
    });
    
    myConn.on('close', () => { 
        alert("与房主断开连接"); 
        location.reload(); 
    });
}

// 核心修复：直接传入 assignedSlot，不再使用 indexOf
function setupHostConnection(conn, assignedSlot) {
    conn.on('open', () => {
        conn.send({ type: 'ASSIGN_ID', id: assignedSlot });
        // 立即同步一次状态
        conn.send({ type: 'SYNC', state: gameState });
    });
    
    conn.on('data', (data) => {
        if (data.type === 'JUMP') {
            // 使用闭包中确定的 assignedSlot，确保绝对正确
            if (gameState.players[assignedSlot]) {
                playerJump(gameState.players[assignedSlot], data.power);
            }
        }
        if (data.type === 'RESTART') startGame();
    });
    
    conn.on('close', () => {
        clientSlots[assignedSlot] = null;
        gameState.players[assignedSlot].active = false;
        log(`P${assignedSlot+1} 断开连接`, "error");
        updateHostStatus();
    });
}

function broadcastState() {
    if (role !== 'HOST') return;
    const data = { type: 'SYNC', state: gameState };
    if(clientSlots[1] && clientSlots[1].open) clientSlots[1].send(data);
    if(clientSlots[2] && clientSlots[2].open) clientSlots[2].send(data);
}

// --- 游戏逻辑 ---
function initGameWorld() {
    gameState.blocks = [];
    gameState.winner = null;
    gameState.blocks.push({ x: 0, y: 0, w: 100, h: BLOCK_SIZE.h, type: 'NORMAL', label: 'START' });
    
    let lastX = 0;
    let index = 1;
    while (lastX < GOAL_DISTANCE) {
        const dist = 150 + Math.random() * 180; 
        lastX += dist;
        if (lastX >= GOAL_DISTANCE) {
            lastX = GOAL_DISTANCE;
            gameState.blocks.push({ x: lastX, y: 0, w: 30, h: BLOCK_SIZE.h, type: 'FINISH', label: 'TOTAL' });
            break;
        } else {
            const labels = ["DATA", "NULL", "REF!", "###", "VAL", index++];
            const label = labels[Math.floor(Math.random()*labels.length)];
            gameState.blocks.push({
                x: lastX, y: 0, w: BLOCK_SIZE.w * (0.8 + Math.random()*0.4), h: BLOCK_SIZE.h, type: 'NORMAL', label: label
            });
        }
    }

    // 重置位置，但不重置 active 状态（因为连接可能还在）
    gameState.players.forEach(p => {
        p.x = 0; p.y = -300; p.vx = 0; p.vy = 0; 
        p.onGround = false; p.finished = false; p.charging = 0; p.lastSafeX = 0;
    });
    
    localCameraX = -200;
    gameState.status = 'PLAYING';
}

function startGame() {
    initGameWorld();
    if(role === 'HOST') broadcastState();
    document.getElementById('game-over-panel').style.display = 'none';
    document.getElementById('menu-panel').style.display = 'none';
}

function updatePhysics() {
    if (gameState.status !== 'PLAYING') return;

    gameState.players.forEach((p, idx) => {
        if (!p.active || p.finished) return;
        
        // 应用重力
        if (!p.onGround) p.vy += GRAVITY;
        
        p.x += p.vx; 
        p.y += p.vy;

        // --- 落地检测 ---
        if (p.y >= 0 && p.vy > 0) {
            for (let b of gameState.blocks) {
                const isWithinHorizontal = Math.abs(p.x - b.x) <= (b.w / 2 - 5);
                // 稍微放宽判定高度，防止穿模
                const isJustTouchingSurface = p.y <= 30; 

                if (isWithinHorizontal && isJustTouchingSurface) {
                    p.y = 0; p.vy = 0; p.vx = 0; p.onGround = true;

                    if (b.type !== 'FINISH') p.lastSafeX = b.x;
                    
                    if (b.type === 'FINISH') {
                        p.finished = true;
                        gameState.winner = idx;
                        gameState.status = 'GAMEOVER';
                    }
                    break;
                }
            }
        }
        
        // --- 掉落重置 ---
        if (p.y > 200) {
            p.x = p.lastSafeX; p.y = -100;
            p.vx = 0; p.vy = 0; p.onGround = false; 
        }
    });

    if(role === 'HOST') broadcastState();
}

function playerJump(p, power) {
    if (!p.onGround || p.finished) return;
    p.onGround = false;
    const rawForce = power / gameConfig.chargeDivisor;
    const jumpPower = Math.min(rawForce, MAX_JUMP_FORCE); 
    p.vy = -9 - jumpPower * 0.7; 
    p.vx = 4 + jumpPower * 0.5;   
}

function draw() {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
    drawGrid(); 

    // 摄像机跟随当前玩家
    const myPlayer = gameState.players[myPlayerIndex] || gameState.players[0];
    const targetCamX = myPlayer.x - SCREEN_W * 0.25;
    localCameraX += (targetCamX - localCameraX) * 0.1;

    ctx.save();
    ctx.translate(-localCameraX, 0);
    const groundY = SCREEN_H / 2 + 100;

    gameState.blocks.forEach(b => {
        if (b.x < localCameraX - 200 || b.x > localCameraX + SCREEN_W + 200) return;
        ctx.fillStyle = b.type === 'FINISH' ? '#ffffcc' : '#f0f0f0';
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        const bx = b.x - b.w/2;
        const by = groundY - b.h;
        ctx.fillRect(bx, by, b.w, b.h);
        ctx.strokeRect(bx, by, b.w, b.h);
        ctx.fillStyle = '#333';
        ctx.font = '12px Consolas';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(b.label || "###", b.x, by + b.h/2);
        
        if (b.x === myPlayer.lastSafeX && b.type !== 'FINISH') {
             ctx.strokeStyle = '#00cc00'; ctx.lineWidth = 2; ctx.strokeRect(bx, by, b.w, b.h);
        }
    });

    gameState.players.forEach((p, i) => {
        if(!p.active) return;
        const px = p.x;
        const py = groundY + p.y - BLOCK_SIZE.h;
        let offsetX = 0;
        if (p.charging > 0) offsetX = (Math.random() - 0.5) * 2;

        ctx.fillStyle = (i === myPlayerIndex) ? '#000' : '#aaa'; 
        ctx.font = 'bold 20px Consolas';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        if (p.finished) ctx.fillText("WIN", px, py);
        else ctx.fillText(p.char, px + offsetX, py);
        
        ctx.font = '10px Arial';
        ctx.fillText(`P${i+1}`, px, py - 22);
    });

    ctx.restore();

    if (isPressing) {
        const power = Date.now() - pressStartTime;
        const maxTime = MAX_JUMP_FORCE * gameConfig.chargeDivisor;
        let percent = Math.min((power / maxTime) * 100, 100).toFixed(1);
        document.getElementById('cell-input').value = `=CALC_JUMP(${percent}%)`;
    } else {
        document.getElementById('cell-input').value = (role === 'SINGLE') ? `=OFFLINE_MODE()` : `=WAITING_P${myPlayerIndex+1}()`;
    }
}

function updateUI() {
    let progressText = "";
    gameState.players.forEach((p, i) => {
        if(p.active) {
            const pct = Math.min((p.x / GOAL_DISTANCE) * 100, 100).toFixed(0);
            progressText += `P${i+1}:${pct}% `;
        }
    });
    document.getElementById('data-progress').innerText = progressText;

    if (gameState.status === 'GAMEOVER') {
        const panel = document.getElementById('game-over-panel');
        if (panel.style.display === 'none') {
            panel.style.display = 'block';
            let msg = "";
            if(gameState.winner === myPlayerIndex) msg = "Output: TRUE (You Win!)";
            else msg = `Output: FALSE (Winner: P${gameState.winner+1})`;
            document.getElementById('game-over-sub').innerText = msg;
        }
    }
}

function loop() {
    if (role === 'HOST' || role === 'SINGLE') updatePhysics();
    
    if (myPlayerIndex >= 0 && gameState.players[myPlayerIndex]) {
        const myP = gameState.players[myPlayerIndex];
        if (isPressing) myP.charging = Date.now() - pressStartTime;
        else myP.charging = 0;
    }
    
    draw();
    updateUI();
    requestAnimationFrame(loop);
}

function handleStart(e) {
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
    if (gameState.status !== 'PLAYING') return;
    if (myPlayerIndex === -1) return;
    
    const myP = gameState.players[myPlayerIndex];
    if (myP.finished) return; 
    // 客户端稍微放宽判定，防止网络延迟导致的无法蓄力
    if (!myP.onGround && role === 'HOST') return; 
    
    isPressing = true;
    pressStartTime = Date.now();
}

function handleEnd(e) {
    if (!isPressing) return;
    isPressing = false;
    const duration = Date.now() - pressStartTime;
    
    if (role === 'HOST' || role === 'SINGLE') {
        playerJump(gameState.players[myPlayerIndex], duration);
    } else if (role === 'CLIENT') {
        if(myConn && myConn.open) myConn.send({ type: 'JUMP', power: duration });
    }
}

function restartRequest() {
    if (role === 'HOST' || role === 'SINGLE') startGame();
    else if(myConn) myConn.send({ type: 'RESTART' });
}

window.addEventListener('mousedown', handleStart);
window.addEventListener('mouseup', handleEnd);
window.addEventListener('resize', () => {
    canvas.width = canvas.parentElement.clientWidth; 
    canvas.height = canvas.parentElement.clientHeight;
    SCREEN_W = canvas.width; SCREEN_H = canvas.height;
});

canvas.width = canvas.parentElement.clientWidth; 
canvas.height = canvas.parentElement.clientHeight;
loop();
</script>
